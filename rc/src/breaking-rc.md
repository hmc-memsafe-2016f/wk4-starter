1. Describe a way to break MyRc by changing something inside an unsafe block or function.
	If consume() didn't check to make sure that there is only one reference before giving you the reference-counted value, then it would zero out the value without droppiing the other RCs. The other RCs might point to a type that's invalid, for example one that has a reference but the underlying pointer is a nullpointer

2. Describe a way to break MyRc by changing something outside an unsafe block of function.
	Changing the initialization of count in the constructor or changing the pointer that the cloned MyRc receives in clone would both break MyRc. Since the code checks that the count is 1 before dropping the data in during drop() or letting you consume() a MyRc, those ifs would be off and it might zero out or drop the underlying data when there are still pointers to it. There is no pointer other than the pointer MyRc has that is guaranteed to be valid (point to initialized memory or point to memory allocated by the program that won't segfault). Thus, changing the pointer that the cloned MyRc receives would allow functions that dereference that pointer in order to get at data or the count (most of them) to segfault.
